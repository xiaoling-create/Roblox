local Http = game:GetService("HttpService")
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- 配置目标物品列表（更新为指定物品）
local TARGET_ITEMS = {
    "Money Printer",
    "Blue Candy Cane",
    "Bunny Balloon",
    "Ghost Balloon",
    "Clover Balloon",
    "Bat Balloon",
    "Gold Clover Balloon",
    "Golden Rose",
    "Black Rose",
    "Heart Balloon",
    "Diamond Ring",
    "Diamond",
    "Void Gem",
    "Dark Matter Gem",
    "Rollie",
    "NextBot Grenade",
    "Nuclear Missile Launcher",
    "Suitcase Nuke",
    "Car",
    "Helicopter",
    "Trident",
    "Golden Cup",
    "Easter Basket"
}

-- 角色移动模拟
local function simulateMovement()
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid:Move(Vector3.new(0, 0, 1), true)
        task.wait(0.01)
        humanoid:Move(Vector3.new(0, 0, 0), false)
    end
end

-- 服务器列表获取函数
local Api = "https://games.roblox.com/v1/games/"
local _place = game.PlaceId
local _servers = Api .. _place .. "/servers/Public?sortOrder=Asc&limit=100"

function ListServers(cursor)
    local url = _servers .. (cursor and "&cursor=" .. cursor or "")
    local success, raw = pcall(function()
        return game:HttpGet(url)
    end)
    if not success then
        warn("获取服务器列表失败: " .. raw)
        return nil
    end
    return Http:JSONDecode(raw)
end

-- 获取随机可用服务器
local function getRandomServer()
    local Server, Next
    repeat
        local Servers = ListServers(Next)
        if not Servers then break end
        local validServers = {}
        for _, srv in ipairs(Servers.data) do
            if srv.id ~= game.JobId and srv.playing < srv.maxPlayers then
                table.insert(validServers, srv)
            end
        end
        if #validServers > 0 then
            local randomIndex = math.random(1, #validServers)
            Server = validServers[randomIndex]
        end
        Next = Servers.nextPageCursor
    until Server or not Next
    return Server
end

local MainScript = [[
    loadstring(game:HttpGet("https://raw.githubusercontent.com/xiaoling-create/Roblox/refs/heads/main/%E5%8D%B0%E9%92%9E%E6%9C%BA%E6%BA%90%E7%A0%81.txt"))()
]]

-- 等待力场消失
repeat
    task.wait()
    simulateMovement()
    task.wait(0.01)
until not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("ForceField"))

-- 安全移动角色
local function safeTeleport(targetCFrame, character)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not rootPart or not humanoid then return false end

    local originalCanCollide = rootPart.CanCollide
    rootPart.CanCollide = false

    local startCFrame = rootPart.CFrame
    local steps = 10
    for i = 1, steps do
        rootPart.CFrame = startCFrame:Lerp(targetCFrame, i / steps)
        RunService.Heartbeat:Wait()
    end

    rootPart.CanCollide = originalCanCollide
    return true
end

-- 查找所有目标物品（检测指定的所有物品）
local function findAllTargetItems()
    local targetItems = {}
    -- 若物品路径不同，需在此处修改（例如添加多个路径检测）
    if workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Entities") and workspace.Game.Entities:FindFirstChild("ItemPickup") then
        for _, v in ipairs(workspace.Game.Entities.ItemPickup:GetChildren()) do
            local primaryPart = v.PrimaryPart
            if primaryPart then
                local prompt = primaryPart:FindFirstChildOfClass("ProximityPrompt")
                if prompt and table.find(TARGET_ITEMS, prompt.ObjectText) then
                    table.insert(targetItems, {
                        part = primaryPart,
                        prompt = prompt,
                        instance = v,
                        type = prompt.ObjectText -- 记录物品类型
                    })
                end
            end
        end
    end
    return targetItems
end

-- 拾取单个物品
local function collectItem(item, character)
    if not character then return false end
    if not item.instance:IsDescendantOf(game) then
        return true -- 物品已消失，视为拾取成功
    end

    local targetCFrame = item.part.CFrame * CFrame.new(0, 1, -3) -- 调整与物品的距离
    local success = safeTeleport(targetCFrame, character)
    if not success then return false end

    task.wait(0.5) -- 等待移动完成
    local interactSuccess = pcall(function()
        fireproximityprompt(item.prompt, 1) -- 触发交互
    end)
    
    if interactSuccess then
        task.wait(1) -- 等待拾取完成
        return true
    else
        warn("拾取 " .. item.type .. "（" .. item.instance.Name .. "）失败")
        return false
    end
end

-- 主逻辑：检测所有目标物品 -> 无则换服 | 有则全拾取后换服
local function main()
    local allItems = findAllTargetItems()
    local targetServer = getRandomServer()

    -- 未找到任何目标物品，直接换服
    if #allItems == 0 then
        print("未检测到任何目标物品，准备换服...")
        if targetServer then
            queue_on_teleport(MainScript)
            task.wait(1)
            TeleportService:TeleportToPlaceInstance(_place, targetServer.id, LocalPlayer)
        else
            warn("未检测到物品且无可用服务器")
        end
        return
    end

    -- 统计每种物品的数量
    local itemCounts = {}
    for _, item in ipairs(allItems) do
        itemCounts[item.type] = (itemCounts[item.type] or 0) + 1
    end
    local countText = {}
    for itemType, count in pairs(itemCounts) do
        table.insert(countText, itemType .. "：" .. count .. "个")
    end
    print("发现目标物品：" .. table.concat(countText, "，") .. "，开始拾取...")

    -- 逐个拾取所有物品
    for i, item in ipairs(allItems) do
        print("正在拾取 " .. i .. "/" .. #allItems .. "（" .. item.type .. "）")
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local success = collectItem(item, character)
        
        if not success then
            warn("重试拾取 " .. i .. "/" .. #allItems .. "（" .. item.type .. "）")
            task.wait(2)
            success = collectItem(item, character)
            if not success then
                warn("放弃拾取 " .. i .. "/" .. #allItems .. "（" .. item.type .. "）")
            end
        end
    end

    -- 拾取完成后检查剩余物品
    local remainingItems = findAllTargetItems()
    if #remainingItems == 0 and targetServer then
        print("所有目标物品已拾取，准备换服...")
        queue_on_teleport(MainScript)
        task.wait(1)
        TeleportService:TeleportToPlaceInstance(_place, targetServer.id, LocalPlayer)
    elseif not targetServer then
        warn("物品拾取完成，但未找到可用服务器")
    else
        print("仍有未拾取的物品：")
        local remainingCounts = {}
        for _, item in ipairs(remainingItems) do
            remainingCounts[item.type] = (remainingCounts[item.type] or 0) + 1
        end
        for itemType, count in pairs(remainingCounts) do
            print("- " .. itemType .. "：" .. count .. "个")
        end
        warn("换服取消")
    end
end

-- 启动主逻辑
main()
